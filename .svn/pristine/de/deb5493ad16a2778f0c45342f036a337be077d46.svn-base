<?php
require_once CORE . 'Encryption.class.php';
require_once CORE . 'Email.class.php';
require_once CORE . 'zebra_database/Zebra_Database.php';

/**
 * User: Rodrigo
 * Date: 12/09/12
 * To change this template use File | Settings | File Templates.
 */
class DataAcess
{
	public $table;

	private $data;

	private $debug = true;
	private $cache = false;

	private $db 			= NULL;		//instancia do banco de dadsa
	private $email 			= NULL; 	//instancia da classe de envio de emais)

	private $db_host = BD_CONFIG_HOST;	// Database Host / IP
	private $db_user = BD_CONFIG_USER;	// Username
	private $db_pass = BD_CONFIG_PASS;	// Password
	private $db_name = BD_CONFIG_DB;	// Database

	//=============================================================================

	public function __construct()
	{
		$this->debug = isset($GLOBALS['debugger']->debugDB)
			? $GLOBALS['debugger']->debugDB
			: false;
	}

	/**
	 * Function to be used to reach the database class for proper configuration
	 */
	private function getDB()
	{
		if( !$this->db )
		{
			$this->db = new Zebra_Database();

			// turn debugging on or off
			$this->db->debug = $this->debug;

			// connect to the MySQL server and select the database
			$this->db->connect(
				$this->db_host,	// host
				$this->db_user,	// user name
				$this->db_pass,	// password
				$this->db_name	// database
			);
		}

		if ( !is_object($this->db) )
		{
			trigger_error('Não foi possível instanciar a classe de banco de dados!', E_USER_ERROR);
		}

		return $this->db;
	}

	/**
	 * Conta o número de correspondencias,
	 * Se nenhum parametro é passado conta o número total de colunas
	 */
	public function dcount($where = '', $replacements = '', $table = NULL, $cache = NULL )
	{
		$table or $table = $this->table;

		$db = $this->getDB();
		return $db->dcount('*', $table, $where, $replacements, $cache);
	}

	public function lookup($where, $vars, $table = NULL, $cache = FALSE)
	{
		$table or $table = $this->table;

		$db = $this->getDB();
		return $db->dlookup('*', $table, $where, $vars, $cache);
	}

	/**
	 * Busca várias linhas de uma tablea que batam com a condição
	 *
	 *  @param string $method: recebe 'all' para buscar todos as entradas de uma tabela ou o nome de uma coluna para ser pesquisada
	 *  @param string/int/float/qualquer_coisa $value: o valor que será comparada na coluna value
	 */
	public function find($where = '', $replacements = '', $columns = '*', $limit = '', $order = '', $cache = FALSE, $calc_rows = false)
	{
		$db = $this->getDB();
		$db->select($columns, $this->table, $where, $replacements, $limit, $order, $cache, false, $calc_rows);
		return $this->fetchResult();
	}

	/**
	 * Busca uma linha da tabela que bata com a condição
	 * Se nenhum where é passado ele assume que a chave buscada é a chave primária (id)
	 */
	public function read($replacements = '', $where = 'id = ?', $columns = '*', $cache = FALSE)
	{
		if ( is_string($replacements) && $replacements !== '' )
		{
			$replacements = array($replacements);
		}

		return $this->find($columns, $where, $replacements, $limit = '1', $cache, $calc_rows = false);
	}

	public function insert($data)
	{
		if ( count($_FILES) > 0 )
		{
			require_once MODEL . 'files.php';
			$files = new Files();
			$ret = $files->upload(); //TODO botar um teste e trigger error aqui
			$data = array_merge_recursive($data, $ret);
		}

		$db = $this->getDB();
		return $db->insert($data);
	}

	public function delete($where)
	{
		$db = $this->getDB();
		return $db->delete($this->tableName,$where);
	}

	public function update($data)
	{
		$db = $this->getDB();
		if(is_object($db))
		{
			return $db->update($data);
		} else echo 'Não instanciou o objeto';
	}

	// Para caso eu decida passar as validações através da variável fields,
	// nesse caso eu terei que separar essas informações aqui.
	private function getValidationRules()
	{
		return $this->validation;
	}

	public function validate($data, $rules = NULL)
	{
		$rules = $rules ? $rules : $this->getValidationRules();
		$validator = $this->validator ? $this->validator : $this->validator = NEW Validator;
		$this->valErrors = $validator->validate($data, $rules);

		return $this->valErrors;
	}

	public function encrypt($string)
	{
		return sha1($string);
	}

	public function autoMail()
	{

	}

	public function email($destination, $from, $message, $subject)
	{
		$this->email or $this->email = new Email($destination,$from);
		return $this->email->sendEmail($subject,$message);
	}

	/**
	 * Preenche o array local$datas com toos os modeloss relacionadas à ese
	 * para que eles se busquem ou insiram no banco

	 */
	private function autoloadRelateds()
	{
		$this->hasMany;
		$this->hasOne;
		$this->belongsTo;
		$this->hasAndBelongsToMany;
	}

	/**
	 * Extrai os resultados retornados pelo bd e as coloca no formato definido pelo sistema.
	 * Deve ser chamada após cada query de select.
	 * Exige que a variável '$relatedModels' esteja preenchida de acordo com o resultado buscado.
	 *

	// vai pegar o array retornado do banco de dados, eliminar as colunas que não são desse modelo de dados
	// e eliminar as repetições
	// se tiver vários ele vai se guiar pelo id e segundo o padrão de nomenclatura de nomes de retormo de query
	// (esse também será montado automaticamente)/
	private function fetchResult()
	{
		if ( !$this->db ) trigger_error('Função fetchResult foi chamada mas nenhuma query foi executada!', E_USER_ERROR);

		$returnedModels = $this->relatedModels;
		$tableName = $this->table;
		$result = array();

		if ( !$returnedModels || !is_array($returnedModels) || count($returnedModels) < 1 )
		{
			$tableName = $this->table;
			while ( $row = $this->db->fetch_assoc() )
			{
			//	$result[][$tableName] = $row;
			}
		}
		else
		{
			$i = 0;

			// pega cada linha do banco de dados
			while ( $row = $this->db->fetch_assoc() )
			{
				$thisRow = array_slice($row, count($this->fields));

				if ( $i == 0 || ( $result[$i-1][$tableName] == $thisRow ) )
				{
					$result[$i][$tableName] = $thisRow;
					$i++;
				}

				// separa cada linha em várias tabelas
				foreach( $returnedModels as $model )
				{
					$thisRow = array_slice($row, count($model->fields));


					if ( $i == 0 || ( $result[$i-1][$model->table] != $thisRow ) )
					{
						if ( isset($result[$i][$tableName]) )
						{

						}
					}
				}

				$i++;
			}
		}

		return $result;
	}
	 */
}
